class VTPState{numAgents;repulsiveLength;alignmentStrength;position;velocity;delaunay;distsToNearest;repulsionVectors;repulsionCoeffs;repulsionFalloff;alignmentVectors;alignmentFalloff;targetComponents;targetComponentIds;targetAssignments;homingVectors;speedModel;iteration;constructor(t,e,i,n="leading geodesic"){this.numAgents=t,this.repulsiveLength=e,this.alignmentStrength=i,this.position=new Array(2*this.numAgents),this.velocity=new Array(2*this.numAgents),this.delaunay=null,this.distsToNearest=new Array(this.numAgents),this.repulsionVectors=new Array(2*this.numAgents),this.repulsionCoeffs=new Array(this.numAgents),this.repulsionFalloff=expTransition,this.alignmentVectors=new Array(2*this.numAgents),this.alignmentFalloff=expTransition,this.targetComponents=[],this.targetComponentIds=[],this.targetAssignments=Array(this.numAgents).fill(""),this.homingVectors=new Array(2*this.numAgents),this.speedModel=n,this.iteration=0}initialize(t,e,i,n){this.position=interleave(t,e),this.velocity=interleave(i,n),this.delaunay=new d3.Delaunay(this.position),this.#t(),this.#e(),this.#i()}randomize(t,e){const i=randomArray(this.numAgents,t[0],t[2]),n=randomArray(this.numAgents,t[1],t[3]),s=randomArray(this.numAgents,0,2*Math.PI),o=s.map(Math.cos),r=s.map(Math.sin);this.initialize(i,n,o,r,e)}setAlignmentStrength(t){this.alignmentStrength=t}addTargetComponent(t,e){if(t.length%2==1)throw"first input must have even length";if(""===e||null===e)throw"invalid target id";e||(e=""),this.targetComponents.push(t),this.targetComponentIds.push(e),this.#t()}assignToTarget(t,e,i){if(i)for(let n=e;n<i;n++)this.targetAssignments[n]=t;else for(let i of e)this.targetAssignments[i]=t;this.#t()}deleteTargetComponent(t,e=null){let i=this.targetComponentIds[t];this.targetComponents.splice(t,1),this.targetComponentIds.splice(t,1),this.assignToTarget(e,allIndicesOf(this.targetAssignments,i)),this.#t()}step(){let t=this.delaunay.voronoi([-1/0,-1/0,1/0,1/0]);for(let e=0;e<this.numAgents;e++){let i=this.repulsionVectors[2*e],n=this.repulsionVectors[2*e+1],s=this.homingVectors[2*e],o=this.homingVectors[2*e+1],r=norm(s,o);0===s&&0===o&&(r=1),s/=r,o/=r;let l=this.alignmentVectors[2*e],a=this.alignmentVectors[2*e+1],h=this.repulsionCoeffs[e],g=h*i+(1-h)*s+this.alignmentStrength*l,u=h*n+(1-h)*o+this.alignmentStrength*a,c=h+(1-h)*(null!==this.targetAssignments[e])+this.alignmentStrength;g/=c,u/=c;let m,p=this.position[2*e],f=this.position[2*e+1];switch(this.speedModel){case"leading geodesic":let i,n;[i,n]=projectToBoundary(t.cellPolygon(e),p,f,g,u,...t.vectors.slice(4*e,4*e+4));let s=norm(p-i,f-n);isNaN(s)&&(s=1/0),m=Math.tanh(s/this.repulsiveLength);break;case"leading straight cone":let o=straightCone(t.cellPolygon(e),p,f,g,u,...t.vectors.slice(4*e,4*e+4)),r=1/0;void 0!==o[0][0]&&(r=polyArea(flattenNx2Array(o))),m=Math.tanh(2*r/(Math.PI*this.repulsiveLength**2))}this.velocity[2*e]=m*g,this.velocity[2*e+1]=m*u,this.position[2*e]+=this.velocity[2*e],this.position[2*e+1]+=this.velocity[2*e+1]}this.delaunay.update(),this.#t(),this.#e(),this.#i(),this.iteration++}#t(){for(let t=0;t<this.numAgents;t++){if(null===this.targetAssignments[t]){this.homingVectors[2*t]=0,this.homingVectors[2*t+1]=0;continue}let e=1/0,i=0,n=0,s=this.position[2*t],o=this.position[2*t+1];const r=allIndicesOf(this.targetComponentIds,this.targetAssignments[t]);for(let t of r){let r,l,a;[r,l,a]=nearestPoint(this.targetComponents[t],s,o),a>e||(e=a,i=r-s,n=l-o)}this.homingVectors[2*t]=i,this.homingVectors[2*t+1]=n}}#e(){for(let t=0;t<this.numAgents;t++){let e,i,n=this.position[2*t],s=this.position[2*t+1],o=this.delaunay.neighbors(t),r=1/0;for(let t of o)i=(n-this.position[2*t])**2+(s-this.position[2*t+1])**2,i>=r||(e=t,r=i);this.distsToNearest[t]=Math.sqrt(r),this.repulsionCoeffs[t]=this.repulsionFalloff(this.distsToNearest[t]/this.repulsiveLength);let l=n-this.position[2*e],a=s-this.position[2*e+1],h=norm(l,a);0===h&&(h=1),this.repulsionVectors[2*t]=l/h,this.repulsionVectors[2*t+1]=a/h}}#i(){for(let t=0;t<this.numAgents;t++){let e=this.velocity[2*t],i=this.velocity[2*t+1],n=norm(e,i);e/=n,i/=n;let s=this.delaunay.neighbors(t),o=0,r=0;for(let t of s){let n=this.velocity[2*t],s=this.velocity[2*t+1],l=norm(n,s);n/=l,s/=l;let a=Math.acos(e*n+i*s),h=this.alignmentFalloff(a/Math.PI);o+=h*n,r+=h*s}this.alignmentVectors[2*t]=1/6*o,this.alignmentVectors[2*t+1]=1/6*r}}render(t,e,i){i||(i=t.getContext("2d")),t.style.width=window.outerWidth+"px",i.clearRect(0,0,t.width,t.height);const n=e[2]-e[0],s=e[3]-e[1];i.scale(t.width,-t.width),i.translate(0,-1),i.scale(1/n,1/s),i.translate(-e[0],-e[1]),i.lineWidth=.001*n,i.save();for(let t of this.targetComponents)i.strokeStyle="rgba(255, 255, 255, 0.4)",i.lineWidth=3*i.lineWidth,2!==t.length?(i.fillStyle="rgba(255, 0, 255, 0.4)",i.beginPath(),polyPath(i,t),i.fill(),i.stroke()):(i.fillStyle="rgba(255, 0, 255, 0.4)",i.beginPath(),i.moveTo(t[0],t[1]),i.arc(t[0],t[1],.005*n,0,2*Math.PI),i.fill());i.restore(),i.beginPath(),this.delaunay.renderPoints(i,.002*n),i.fill(),i.beginPath(),i.strokeStyle="#666",quiver(i,this.position,this.velocity),i.stroke(),i.beginPath(),i.strokeStyle="rgba(0, 200, 0, 0.5)",quiver(i,this.position,this.homingVectors),i.stroke(),i.resetTransform()}exportData(){const t=Array(this.numAgents).fill(Array(4)).map(((t,e)=>[this.position[2*e],this.position[2*e+1],this.velocity[2*e],this.velocity[2*e+1]]));arrayToCSV(t,["positionX","positionY","velocityX","velocityY"],"data")}polarization(){let t=0,e=0,i=0;for(let n=0;n<this.numAgents;n++){let s=this.velocity[2*n],o=this.velocity[2*n+1];t+=s,e+=o,i+=norm(s,o)}return norm(t,e)/i}angularMomentum(t=!1){let e=0,i=0;for(let n=0;n<this.numAgents;n++){let s=this.position[2*n],o=this.position[2*n+1],r=this.velocity[2*n],l=this.velocity[2*n+1],a=s*l-o*r;t&&(a=Math.abs(a)),e+=a,i+=norm(s,o)*norm(r,l)}return e=Math.abs(e),e/i}voronoiPressure(){const t=this.delaunay.voronoi([-1/0,-1/0,1/0,1/0]);let e=this.delaunay.hull.sort(((t,e)=>t-e)),i=0;for(let n=0;n<this.numAgents;n++){if(n===e[0]){e=e.slice(1);continue}i+=1/polyArea(flattenNx2Array(t.cellPolygon(n)).slice(2))}return i/=this.numAgents,i}medianRadius(){let t=0,e=0;for(let i=1;i<this.numAgents;i++)t+=this.position[2*i],e+=this.position[2*i+1];t/=this.numAgents,e/=this.numAgents;const i=Array(this.numAgents).fill(1/0).map(((i,n)=>normSquare(this.position[2*n]-t,this.position[2*n+1]-e))).sort(((t,e)=>t-e)),n=i[Math.floor(i.length/2)];return Math.sqrt(n)}centralTriangleArea(){let t=0,e=0;for(let i=1;i<this.numAgents;i++)t+=this.position[2*i],e+=this.position[2*i+1];t/=this.numAgents,e/=this.numAgents;const i=this.delaunay.triangles;for(let n=0;n<i.length/3;n++){const s=i[3*n],o=i[3*n+1],r=i[3*n+2],l=this.position[2*s],a=this.position[2*s+1],h=this.position[2*o],g=this.position[2*o+1],u=this.position[2*r],c=this.position[2*r+1];if(isInside([l,a,h,g,u,c],t,e))return polyArea([l,a,h,g,u,c])}return-1}}function polyArea(t){let e=0,i=t.length/2;for(let n=0;n<i;n++)e+=t[2*n]*t[(n+1)%i*2+1]-t[(n+1)%i*2]*t[2*n+1];return Math.abs(e/2)}function sign(t){return(t[0]-t[4])*(t[3]-t[5])-(t[2]-t[4])*(t[1]-t[5])}function isInside(t,e,i){if(t.length%2==1)throw"must have even length for x and y coordinates of each vertex";if(t.length<6)throw"polygon must have at least three vertices";if(6===t.length){const n=sign([e,i,...t.slice(0,4)]),s=sign([e,i,...t.slice(2,6)]),o=sign([e,i,...t.slice(4,6),...t.slice(0,2)]);return!((n<0||s<0||o<0)&&(n>0||s>0||o>0))}for(let n=1;n<=t.length/2-2;n++)if(isInside([...t.slice(0,2),...t.slice(2*n,2*n+4)],e,i))return!0;return!1}function rescale(t,e,i,n=0,s=1){return(i-e)*(t-n)/(s-n)+e}function randomArray(t,e=0,i=1){return Array.from({length:t},(()=>rescale(Math.random(),e,i)))}function interleave(t,e){if(t.length!=e.length)throw"inputs must have the same length";C=new Array(2*t.length);for(let i=0;i<t.length;i++)C[2*i]=t[i],C[2*i+1]=e[i];return C}function norm(t,e){return Math.sqrt(t*t+e*e)}function expTransition(t){if(t>=1)return 0;const e=t=>Math.exp(-1/t);return e(1-t)/(e(t)+e(1-t))}function expTransitionAttr(t){return rescale(expTransition(t),-1,1)}function quiver(t,e,i,n=1){for(let s=0;s<e.length/2;s++)t.moveTo(e[2*s],e[2*s+1]),t.lineTo(e[2*s]+n*i[2*s],e[2*s+1]+n*i[2*s+1])}function polyPath(t,e){if(e.length%2==1)throw"input must have even length";t.moveTo(e[0],e[1]);for(let i=1;i<e.length/2;i++)t.lineTo(e[2*i],e[2*i+1]);e.length<6||t.closePath()}function polyPath2d(t,e){t.moveTo(e[0][0],e[0][1]);for(let i=1;i<e.length;i++)t.lineTo(e[i][0],e[i][1]);t.closePath()}function allIndicesOf(t,e){const i=[];let n=t.indexOf(e);for(;-1!==n;)i.push(n),n=t.indexOf(e,n+1);return i}function nearestPoint(t,e,i){if(t.length%2==1)throw"input must have even length";let n=t.length/2,s=1/0,o=e,r=i;if(1===n)return o=t[0],r=t[1],s=normSquare(e-o,i-r),[o,r,s];if(2==n)return[o,r]=nearestOnSegment(...t,e,i),s=normSquare(e-o,i-r),[o,r,s];if(isInside(t,e,i))return[e,i,0];for(let l=0;l<n;l++){let a,h;[a,h]=nearestOnSegment(t[2*l],t[2*l+1],t[(l+1)%n*2],t[(l+1)%n*2+1],e,i),currentDist=normSquare(e-a,i-h),currentDist>s||(s=currentDist,o=a,r=h)}return[o,r,s]}function nearestOnSegment(t,e,i,n,s,o){let r=Math.atan2(n-e,i-t),l=Math.sin(r),a=Math.cos(r),h=a*t+l*e,g=-l*t+a*e,u=a*i+l*n,c=a*s+l*o,m=Math.min(h,u),p=Math.max(h,u),f=c;return c<m&&(f=m),c>p&&(f=p),[a*f-l*g,l*f+a*g]}function normSquare(t,e){return t*t+e*e}function intersectRayXSegmentOrRay(t,e,i,n,s,o,r,l,a=!0){let h=(i-t)*(o-l)-(s-r)*(n-e);if(0===h)return[NaN,NaN];let g=1/h*(-(n-e)*(s-t)+(i-t)*(o-e));return 1/h*((o-l)*(s-t)-(s-r)*(o-e))<0||g<0||g>1&&a?[NaN,NaN]:[s+g*(r-s),o+g*(l-o)]}function projectToBoundary(t,e,i,n,s,o,r,l,a){let h,g,u,c,m,p,f=t.length-1;if(void 0!==t[0][0]){for(let o=0;o<f;o++)if(u=t[o][0],c=t[o][1],m=t[o+1][0],p=t[o+1][1],[h,g]=intersectRayXSegmentOrRay(e,i,e+n,i+s,u,c,m,p),!isNaN(h))return[h,g];return[NaN,NaN]}if(u=t[1][0],c=t[1][1],m=u+o,p=c+r,[h,g]=intersectRayXSegmentOrRay(e,i,e+n,i+s,u,c,m,p,!1),!isNaN(h))return[h,g];for(let o=1;o<f-1;o++)if(u=t[o][0],c=t[o][1],m=t[o+1][0],p=t[o+1][1],[h,g]=intersectRayXSegmentOrRay(e,i,e+n,i+s,u,c,m,p),!isNaN(h))return[h,g];return u=t[f-1][0],c=t[f-1][1],m=u+l,p=c+a,[h,g]=intersectRayXSegmentOrRay(e,i,e+n,i+s,u,c,m,p,!1),isNaN(h)?[NaN,NaN]:[h,g]}function straightCone(t,e,i,n,s,o,r,l,a){let h,g,u,c;if([h,g]=projectToBoundary(t,e,i,s,-n,o,r,l,a),[u,c]=projectToBoundary(t,e,i,-s,n,o,r,l,a),isNaN(h)||isNaN(u))return[[void 0,void 0]];if(void 0!==t[0][0]){let n=[[h,g],[u,c],...t.slice(0,-1)],s=n.map(((t,n)=>[Math.atan2(t[1]-i,t[0]-e),n]));s=s.sort(((t,e)=>t[0]-e[0]));let o=s.map((t=>t[1]));for(n=o.map((t=>n[t]));0!==o[0];)o=[...o.slice(1),o[0]],n=[...n.slice(1),n[0]];let r=o.indexOf(1);return n.slice(0,r+1)}let m=[[h,g],[u,c],[e+l,i+a],[e+o,i+r],...t.slice(1,-1)],p=m.map(((t,n)=>[Math.atan2(t[1]-i,t[0]-e),n]));p=p.sort(((t,e)=>t[0]-e[0]));let f=p.map((t=>t[1]));for(m=f.map((t=>m[t]));0!==f[0];)f=[...f.slice(1),f[0]],m=[...m.slice(1),m[0]];const d=f.indexOf(1);return f.indexOf(2)<d?[[void 0,void 0]]:m.slice(0,d+1)}function circShift(t,e){const i=t,n=i.splice(0,e);return[...i,...n]}function flattenNx2Array(t){let e=t.length;const i=new Array(e);for(let n=0;n<e;n++)i[2*n]=t[n][0],i[2*n+1]=t[n][1];return i}